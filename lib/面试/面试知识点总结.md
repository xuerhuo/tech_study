面试实战部分整理
-

# JAVA基础

### HashMap与HashTable比较

HashMap

- HashMap底层数据结构是 ***数组+链表*** ,jdk8以后当节点超过8个以后，转化为 ***红黑树*** 处理
- HashMap是 线程不安全的
- 可以接受null



HashTable

- HashTable底层数据是哈希表
- HashTable是 线程安全的
- 不可以接受null
- 线程竞争激烈的情况下 HashTable 的效率非常低下

比较: 单线程下HashMap性能要好过HashTable, 多线程情况下使用 ***ConcurrentHashMap*** 替换HashTable

参考网址
- [http://www.importnew.com/7010.html](http://www.importnew.com/7010.html)


### ConcurrentHashMap

介绍:ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素, 当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。



参考网址

- [https://blog.csdn.net/justloveyou_/article/details/72783008](https://blog.csdn.net/justloveyou_/article/details/72783008) 
- [https://www.infoq.cn/article/ConcurrentHashMap](https://www.infoq.cn/article/ConcurrentHashMap)


# Netty相关

BIO、NIO、AIO 的原理及区别与应用场景 [参考](https://blog.csdn.net/guanghuichenshao/article/details/79375967)

- BIO（Blocking I/O）-同步阻塞： 一个连接一个线程，BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。
- NIO（Non-blocking I/O）-同步非阻塞：一个请求一个线程，NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。***Netty是NIO的一种实现方式。***
- AIO（Asynchronous I/O）-异步非阻塞：一个有效请求一个线程。AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。









# 计算机网络

![avatar](https://github.com/sanwancoder/it_study_lib/blob/master/images/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png?raw=true)

TCP与UDP

- TCP: Transmission Control Protocol 传输控制协议
- UDP: User Datagram Protocol        用户数据报协议
- 相同点
   - 传输层协议
- 不同点 
![avatar](https://github.com/sanwancoder/it_study_lib/blob/master/images/TCP%E4%B8%8EUPD%E6%AF%94%E8%BE%83.png?raw=true)

IP

- 介绍:Internet Protocol,是网络层协议



 

参考地址

   - [TCP和UDP比较 掘金网](https://juejin.im/post/5c6fbf54f265da2db718216a) 
   - 
  
      
# ELK

Elasticsearch 

- 搭建


Logstash


# 多线程

线程状态与转换

- new runable running wait sleep dead


线程



# JVM

JVM内存结构？

- 堆区、方法区、JVM栈、本地方法栈、程序计算器

那些对象回进入老年代？ ***考察对象分配规则知识***

- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。


